G-P-M模型抽象结构： https://blog.csdn.net/chenxun_2010/article/details/104053014G: 表示Goroutine，每个Goroutine对应一个G结构体，G存储Goroutine的运行堆栈、状态以及任务函数，可重用。   G运行队列是一个栈结构，分全局队列和P绑定的局部队列，每个G不能独立运行，它需要绑定到P才能被调度执行。P: Processor，表示逻辑处理器， 对G来说，P相当于CPU核，G只有绑定到P(在P的local runq中)才能被调度。   对M来说，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，   P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 >= P的数量）   ，P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。M: Machine，系统物理线程，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环；   而schedule循环的机制大致是从Global队列、P的Local队列以及wait队列中获取G，   切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到M，如此反复。   M并不保留G状态，这是G可以跨M调度的基础，M的数量是不定的，由Go Runtime调整，   为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。